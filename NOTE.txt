////////////////////////////////////////////////////////////////////////////////////////////////////
1.배열 초기화는 전역변수는 BSS 영역에서 자동으로 0으로 초기화되만 지역변수 STACK영역에서 자동으로 초기화 되지 않는다.
2.string에서 한 문자만 빼면 char형식으로 저장해야한다.
3.double a = (double)b / (double)c; 처럼 b와 c를 double형으로 만들어라(PROG_37_1)
4.int a = char - 48;  //char를 int로 만드는법
5.  3번한다.
    int n=3;
    while(n--)
    {
        cout<<n<<endl;  //2,1,0
    }
6.map관련문제는 범위를 잘파악하자!(세로길이가 [i][j]에서 i로 와야지)
7.전역변수로 vector<int> vec; 선언시 사이즈 주의하자
함수안에서만 범위가 작동한다.
즉 범위내에서 초기화해서 작동하는 것으로 보인다.
vector<int> vec;
void func()
{
    cout << vec.size() << endl; // 0
}

int main()
{
    vector<int> vec(4, 0);
    cout << vec.size() << endl; // 4
    func();
}
8.벡터 첫번째 원소넣는법
9.deque<int> map[10][10]
map[0][1].push_back(3);방식으로 사용가능(BOJ_5_5.나무재테크.cpp)
10.초과 이상 잘 파악하기
sort_rule잘사용하기(BOJ_7_1.이차원배열.cpp)
11.문제에서 [0][0]을 [1][1]로 정의함을 잊었다.
이동이 모두 끝난 뒤, 2개 이상의 파이어볼이 있는 칸에서는 다음과 같은 일이 일어난다(BOJ_11_1.마법사상어와파이어볼.cpp)
12.이분탐색은 규칙이 있다. 하지만 bool check하는 부분의 생각싸움인듯
13.
이진tree구조인데 map과 다른점이 있다.
set is an associative container that conains a sorted set of nuique objects of type key
set은 key유형의 고유한 객체 (정렬된)집합을 포함하는 연관 컨테이너를 말한다.
나는 쉽게 tree에 저장한다고 생각하기로 했다. tree로 저장하니깐 당연히 정렬이 되고
map은 hash처럼 key와 value로 저장한다.

multiset과 set의 차이는 set은 요소를 추가할때 중복이 있으면 넣지 않는다
예를들어 1,1,2,3,4를 넣으면 1이 중복되니 set에는 1,2,3,4로 저장된다
반면 multiset은 중복을 허락해서 1,1,2,3,4,5로 저장한다.

map은 자동적으로 작은거부터 저장한다.(자동으로 오름차순)

set<int, greater<int>>;
set<int, less<int>>;

14.
★min과 max값 뽑기
auto iter = --setnum.end();
cout << (*iter) << endl;//제일 작은수 
iter = setnum.begin();
cout << (*iter) << endl;//제일큰수

15.모듈(%)는 언제 제자리로 돌아오는지 파악하면 된다.(BOJ_18_1.낚시왕.cpp)
16.=과 == 실수포인트
17.★void함수가 아니면 무조건 return 값을 넣어야한다.(BOJ_23_1.청소년상어.cpp)
18.getline(cin, str); : 한줄 다 받는법
19.함수인자로 넘길때 웬만하면 &쓰자. 속도차이가 난다(BOJ_24_1.어른상어_R1.cpp)


////////////////////////////////////////////////////////////////////////////////////////////////////
Programmers
1. 구현
2. 구현
3. hash
4. hash
5. hash,sort정책사용
6. 우선순위큐 사용법,우선순위큐 정책사용
7. max_element사용 (sort 정책으로 풀어봐라_코드보면 설명있음)
8. 구현
9. 우선순위큐&multimap사용(multimap max min뽑아내기& iterator이해)
10.정렬
11.정렬(string을 정책사용)
12.구현
13.구현
14.DFS
15.구현(Vector Index로 해결)
16.Kruskal 알고리즘
   Greedy를 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것
17.구현(X)
18.DFS
19.DFS
20.DFS
21.DFS
22.DP
23.DP(X)
24.string이용(X)
25.string이용
26.BFS
27.STACK
28.구현
29.구현
30.구현
31.구현
32.구현
33.구현(string이용)_Hint
34.좌표사용구현 좌표의 범위를 잘 파악하자
35.구현
36.구현
37.투포인터방식(2개의 idx사용)
38.이분탐색
39.set사용 or 링크트리스트
40.구현
41.map관련 구현
42.2차원누적합(X)
43.블록이동하기(X)
44.이분탐색
45.이분탐색
////////////////////////////////////////////////////////////////////////////////////////////////////

H-Index : 문제이해어려움
카펫
조이스틱 : 전설의 문제같음 
           답이 없는건 아님
           https://4z7l.github.io/2021/03/12/algorithms-prg-42860.html
           그런데 dfs로는 구현이 어렵고 그리디로 풀려니깐 도저히 안풀림
           인터넷에 있는 다른 풀이도 다 틀림